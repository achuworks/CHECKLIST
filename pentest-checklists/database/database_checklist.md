Database Security Penetration Testing Checklist
This checklist provides a comprehensive guide for conducting penetration testing on databases used in Learning Management Systems (LMS) or Loan Origination Systems (LOS) applications. 
It covers SQL and NoSQL databases, addressing advanced vulnerabilities such as injection attacks, deserialization, privilege escalation, and log tampering, with obfuscation techniques to bypass security controls. 
The checklist aligns with OWASP Testing Guide, NIST SP 800-115, CIS Database Benchmarks, and compliance requirements like FERPA (LMS) and GLBA (LOS), ensuring robust protection of sensitive data (e.g., student grades, loan details).

1. Information Gathering
Objective
Collect database information to identify attack vectors, configurations, and potential weaknesses.

Enumerate Database Type and Version

Identify database type (e.g., MySQL, PostgreSQL, MongoDB, Oracle) using Nmap scripts (e.g., nmap --script mysql-info <target>).
Extract version details via error messages, banners, or connection responses.
Use OSINT tools (e.g., Shodan, Censys) to detect exposed database ports (e.g., 3306 for MySQL, 27017 for MongoDB).


Map Database Connections

Identify application-to-database connection strings in configuration files (e.g., web.config, application.properties).
Check for exposed database ports using netstat -tulnp or nmap -p 3306,27017 <target>.
Enumerate database users via error messages or brute-forcing tools (e.g., hydra -L users.txt -P passwords.txt mysql://<target>).


Enumerate Database Schema

Attempt schema extraction via SQL injection (e.g., SELECT * FROM information_schema.tables).
Test NoSQL schema enumeration (e.g., MongoDB db.getCollectionNames() or db.collection.find()).
Check for exposed admin interfaces (e.g., phpMyAdmin, Mongo Express, pgAdmin) using directory enumeration tools like Gobuster.


Identify Sensitive Data

Map tables/collections storing sensitive LMS/LOS data (e.g., student PII, loan financial details).
Check for metadata exposure in database comments or documentation files.
Verify compliance requirements (e.g., FERPA for student data, GLBA for financial data).



2. Configuration Testing
Objective
Identify misconfigurations that could expose the database to unauthorized access or attacks.

Test Database Configuration

Verify secure settings per CIS Benchmarks (e.g., MySQL secure_file_priv, MongoDB bind_ip=127.0.0.1).
Check for default credentials (e.g., root:root, admin:admin) using db_config_test.sh.
Ensure encryption at rest (e.g., MySQL Transparent Data Encryption, MongoDB encrypted storage).
Test for disabled dangerous features (e.g., MySQL LOAD DATA LOCAL INFILE, PostgreSQL COPY FROM PROGRAM).


Test Network Access

Verify databases are not bound to public interfaces (e.g., 0.0.0.0) using netstat -tulnp.
Check for IP whitelisting or firewall rules restricting access (e.g., iptables -L).
Test for unauthorized remote connections using Netcat (e.g., nc -zv <target> 3306).


Test Logging Configuration

Ensure query logs exclude sensitive data (e.g., no passwords in MySQL general_log).
Verify audit logs capture critical actions (e.g., schema changes, user logins) with timestamps and user IDs.
Check log storage permissions (e.g., chmod 640 /var/log/mysql/*) to prevent tampering.


Test Backup Configuration

Verify database backups are encrypted (e.g., AES-256) and stored with restricted access.
Check for exposed backup files (e.g., dump.sql, backup.bson) in web directories or misconfigured shares.
Test for predictable backup filenames (e.g., db-2025-06-20.sql).



3. Access Control Testing
Objective
Prevent unauthorized access to database resources and ensure proper role-based access.

Test User Privileges

Verify least privilege for database users (e.g., no ALL PRIVILEGES for application accounts) using SHOW GRANTS (SQL) or db.getRoles() (MongoDB).
Test for excessive permissions (e.g., FILE, PROCESS, SUPER in MySQL) that could lead to escalation.
Check for anonymous or guest accounts (e.g., MySQL anonymous@%, MongoDB default users).


Test Role-Based Access Control (RBAC)

Ensure application users cannot execute administrative functions (e.g., DROP TABLE, db.dropDatabase()).
Test for privilege escalation via misconfigured roles, stored procedures, or triggers.
Verify RBAC aligns with LMS/LOS roles (e.g., students cannot access teacher data, applicants cannot access underwriter data).
Apply obfuscation (e.g., Base64-encoded role names, JSON-wrapped parameters) to test bypasses.


Test Authentication Mechanisms

Check for weak passwords using brute-force tools (e.g., hydra -l root -P wordlist.txt mysql://<target>).
Verify strong authentication methods (e.g., certificate-based auth for PostgreSQL, SCRAM-SHA-256 for MongoDB).
Test for authentication bypass via parameter tampering (e.g., user=admin&pass=%00).



4. Injection Testing
Objective
Prevent injection attacks that could compromise data integrity, confidentiality, or availability.

Test for SQL Injection

Test all input fields (e.g., login forms, search bars, API endpoints) using SQLmap (e.g., sqlmap -u <target> --batch).
Use manual payloads for blind and out-of-band injections (e.g., ' OR 1=1 --, UNION SELECT * FROM users, SLEEP(5)).
Apply obfuscation techniques:
URL encoding (e.g., %27 for ', %3B for ;).
Mixed case (e.g., SeLeCt * FrOm UsErS).
Null bytes (e.g., %00), newlines (\r\n), or comments (e.g., /*comment*/).
Double encoding (e.g., %2527).
Time-based or Boolean-based queries (e.g., IF(1=1,SLEEP(5),0)).




Test for NoSQL Injection

Test MongoDB, CouchDB, or other NoSQL databases for injection (e.g., {"$ne":null}, {"$where":"sleep(1000)"}).
Check for JSON injection in API payloads (e.g., {"username":{"$gt":""}}, {"$regex":".*"}).
Use obfuscated payloads:
Base64-encoded queries (e.g., eyIkbmUiOm51bGx9 for {"$ne":null}).
Nested JSON structures (e.g., {"$in":[{"$eq":"admin"}]}).
Unicode or malformed inputs (e.g., %EF%BC%84ne for $ne).




Test for Command Injection

Check for command execution via stored procedures, triggers, or database extensions (e.g., MySQL UDF, PostgreSQL CREATE FUNCTION).
Test with obfuscated commands (e.g., $(whoami), w${h}oami, cat${IFS}/etc/passwd).
Attempt RCE via database functions (e.g., MySQL INTO OUTFILE, PostgreSQL COPY TO PROGRAM).


Test for XML External Entity (XXE) Injection

Test XML-processing database inputs for XXE (e.g., <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>).
Attempt SSRF via XXE to access internal resources (e.g., http://localhost:8080).
Use obfuscated XML payloads (e.g., Base64-encoded entities, nested DTDs).



5. Data Protection Testing
Objective
Protect sensitive LMS/LOS data from unauthorized access or leakage.

Test Data Encryption

Verify encryption of sensitive data (e.g., student PII, loan amounts) using AES-256 or equivalent.
Check for encryption key exposure in configuration files, environment variables, or source code.
Ensure secure key management (e.g., use of HSM or KMS for key storage).


Test Data Leakage

Check query responses for excessive data exposure (e.g., SELECT * returning SSNs or credit card numbers).
Test for sensitive data in error messages, debug outputs, or temporary tables/views.
Verify no sensitive data in database logs (e.g., MySQL general_log, MongoDB profile).


Test Data Anonymization

Ensure data used for analytics or testing is anonymized (e.g., hashed PII).
Test for re-identification risks in anonymized datasets.
Verify compliance with FERPA (LMS) or GLBA (LOS) for data handling.


Test Data Retention

Check for secure deletion of data per retention policies (e.g., SHRED for SQL dumps).
Verify no residual data in deleted tables/collections (e.g., MongoDB dropped collections).
Ensure compliance with GDPR (if applicable) for data deletion requests.



6. Advanced Vulnerability Testing
Objective
Identify advanced vulnerabilities that could compromise the database or application.

Test for Deserialization Vulnerabilities

Identify database extensions, triggers, or stored procedures using serialized objects (e.g., Java, PHP, Python).
Test for insecure deserialization using ysoserial (e.g., ysoserial.jar CommonsCollections4 "whoami").
Attempt RCE, data tampering, or privilege escalation via crafted serialized objects.
Use obfuscated payloads (e.g., Base64-encoded objects, nested serialization).


Test for Privilege Escalation

Test for escalation via misconfigured stored procedures or triggers (e.g., MySQL DEFINER privilege abuse).
Check for excessive permissions on database functions (e.g., PostgreSQL pg_sleep, MongoDB eval).
Use obfuscated queries to bypass restrictions (e.g., EXEC/*comment*/sp_configure, Base64-encoded function names).


Test for Server-Side Request Forgery (SSRF)

Test database functions for SSRF (e.g., MySQL LOAD DATA accessing http://localhost, Oracle UTL_HTTP).
Use obfuscated URLs:
Decimal IPs (e.g., 2130706433 for 127.0.0.1).
Malformed domains (e.g., 127.0.0.1.nip.io).
Protocol variations (e.g., file://, gopher://).


Attempt access to internal resources or metadata (e.g., /proc/self).


Test for Time-Based Attacks

Confirm blind SQL/NoSQL injections using time-based techniques (e.g., SLEEP(5), db.sleep(1000)).
Test for DoS via heavy queries (e.g., SELECT BENCHMARK(1000000,MD5(1))).
Verify rate-limiting or query timeouts to mitigate DoS risks.


Test for Race Conditions

Test for time-of-check/time-of-use vulnerabilities in database transactions (e.g., simultaneous updates to loan status).
Use tools like Burp Suiteâ€™s Turbo Intruder to simulate race conditions.
Check for data corruption or unauthorized changes due to race conditions.



7. Log and Monitoring Testing
Objective
Ensure database logs are secure, tamper-proof, and compliant with LMS/LOS requirements.

Test Log Integrity

Attempt log tampering via injection (e.g., ; INSERT INTO audit_log (msg) VALUES ('fake')).
Verify logs are stored with read-only permissions (e.g., chmod 640 /var/log/mysql/*).
Check for log rotation and retention policies compliant with FERPA/GLBA (e.g., 1-year retention).


Test Log Content

Ensure no sensitive data (e.g., passwords, SSNs) in logs (e.g., MySQL general_log, MongoDB profile).
Verify logging of critical events (e.g., failed logins, schema changes, data exports).
Test for log poisoning (e.g., injecting fake entries via crafted queries or headers).


Test Monitoring

Check for real-time monitoring of database security events (e.g., IDS/IPS integration).
Test for alerting on suspicious activities (e.g., multiple failed logins, large data exports).
Verify audit trails link to LMS/LOS user actions (e.g., teacher grade changes, underwriter approvals).



8. Backup and Recovery Testing
Objective
Secure database backups and prevent unauthorized access or data loss.

Test Backup Access

Check for exposed backup files in web directories or shares (e.g., /backups/dump.sql).
Verify backups are encrypted (e.g., AES-256) and stored with restricted access (e.g., chmod 600).
Test for predictable backup filenames (e.g., db-2025-06-20.bson) using directory enumeration.


Test Backup Restoration

Ensure restoration processes require authentication and authorization.
Test for data integrity during restoration (e.g., no tampering or corruption).
Verify restoration does not expose sensitive data (e.g., no plaintext dumps).


Test Backup Security

Check for backup scripts with hardcoded credentials (e.g., mysqldump --user=root --password=pass).
Test for backup exposure via misconfigured cron jobs (e.g., crontab -l).
Ensure backups comply with FERPA/GLBA retention and encryption requirements.



9. Obfuscation Techniques
Objective
Test database defenses against obfuscated inputs that may bypass filters or security controls.

Encoding Techniques

Use Base64, URL, ASCII, Hex, Binary, Octal, or Gzip encoding for queries and payloads.
Apply double encoding (e.g., %2527 for ') or null bytes (%00).
Test with Unicode or malformed inputs (e.g., S%EF%BC%E5L%EF%BC%C5CT, %EF%BC%84ne for $ne).


Query Obfuscation

Mix case in queries (e.g., SeLeCt * FrOm UsErS, dB.gEtCoLlEcTiOnNaMeS()).
Use nested queries, comments, or whitespace variations (e.g., SELECT/*comment*/password, db.collection . find()).
Wrap payloads in JSON, arrays, or nested structures (e.g., {"$eq":"admin"}, [{"$ne":null}]).


Parameter Manipulation

Test parameter tampering with encoded values (e.g., username=%61dmin, query=%53%45%4C%45%43%54).
Use malformed parameters to confuse parsers (e.g., query=;SELECT%00, user={"$gt":""}).
Combine with HTTP parameter pollution (e.g., param=1Â¶m=2) for API-driven queries.


Command Obfuscation

Obfuscate database commands (e.g., $(eval), e${v}al for MongoDB eval).
Use environment variable manipulation or chained commands (e.g., cat${IFS}/etc/passwd | base64).
Test with recursive encoding to evade WAFs or input validation.



10. Tools 

Injection Testing: SQLmap, NoSQLMap, Hackbar
Configuration Testing: OpenSCAP, Lynis
Access Control Testing: Burp Suite, custom Python scripts
Deserialization Testing: ysoserial
Log Analysis: LogParser, Splunk, ELK Stack
Backup Testing: Dirsearch, Gobuster for backup file enumeration


11. References

OWASP Testing Guide
CIS Database Benchmarks (MySQL, PostgreSQL, MongoDB, Oracle)
NIST SP 800-115
MongoDB Security Checklist
SecLists for injection payloads and wordlists
MITRE ATT&CK for database attack techniques
OWASP SQL Injection Cheat Sheet
NoSQL Injection Cheat Sheet

